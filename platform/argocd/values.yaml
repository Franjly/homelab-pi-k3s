argo-cd:
  configs:
    # knownHosts:
    #   data:
    #     # -- Known Hosts
    #     # @default -- See [values.yaml]
    #     ssh_known_hosts: |
    #       bitbucket.org ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEAubiN81eDcafrgMeLzaFPsw2kNvEcqTKl/VqLat/MaB33pZy0y3rJZtnqwR2qOOvbwKZYKiEO1O6VqNEBxKvJJelCq0dTXWT5pbO2gDXC6h6QDXCaHo6pOHGPUy+YBaGQRGuSusMEASYiWunYN0vCAI8QaXnWMXNMdFP3jHAJH0eDsoiGnLPBlBp4TNm6rYI74nMzgz3B9IikW4WVK+dc8KZJZWYjAuORU3jc1c/NPskD2ASinf8v3xnfXeukU0sJ5N6m5E8VLjObPEO+mN2t/FZTMZLiFqPWc/ALSqnMnnhwrNi2rbfg/rd/IpL8Le3pSBne8+seeFVBoGqzHM9yXw==
    #       github.com ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBEmKSENjQEezOmxkZMy7opKgwFB9nkt5YRrYMjNuG5N87uRgg6CLrbo5wAdT/y6v0mKV0U2w0WZ2YB/++Tpockg=
    #       github.com ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIOMqqnkVzrm0SdG6UOoqKLsabgH5C9okWi0dh2l9GKJl
    #       github.com ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEAq2A7hRGmdnm9tUDbO9IDSwBK6TbQa+PXYPCPy6rbTrTtw7PHkccKrpp0yVhp5HdEIcKr6pLlVDBfOLX9QUsyCOV0wzfjIJNlGEYsdlLJizHhbn2mUjvSAHQqZETYP81eFzLQNnPHt4EVVUh7VfDESU84KezmD5QlWpXLmvU31/yMf+Se8xhHTvKSCZIFImWwoG6mbUoWf9nzpIoaSjB+weqqUUmpaaasXVal72J+UX2B+2RPW3RcT0eOzQgqlJL3RKrTJvdsjE3JEAvGq3lGHSZXy28G3skua2SmVi/w4yCE6gbODqnTWlg7+wC604ydGXA8VJiS5ap43JXiUFFAaQ==
    #       gitlab.com ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBFSMqzJeV9rUzU4kWitGjeR4PWSa29SPqJ1fVkhtj3Hw9xjLVXVYrU9QlYWrOLXBpQ6KWjbjTDTdDkoohFzgbEY=
    #       gitlab.com ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIAfuCHKVTjquxvt6CM6tdG4SLp1Btn/nOeHHE5UOzRdf
    #       gitlab.com ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCsj2bNKTBSpIYDEGk9KxsGh3mySTRgMtXL583qmBpzeQ+jqCMRgBqB98u3z++J1sKlXHWfM9dyhSevkMwSbhoR8XIq/U0tCNyokEi/ueaBMCvbcTHhO7FcwzY92WK4Yt0aGROY5qX2UKSeOvuP4D6TPqKF1onrSzH9bx9XUf2lEdWT/ia1NEKjunUqu1xOB/StKDHMoX4/OKyIzuS0q/T1zOATthvasJFoPrAjkohTyaDUz2LN5JoH839hViyEG82yB+MjcFV5MU3N1l1QL3cVUCh93xSaua1N85qivl+siMkPGbO5xR/En4iEY6K2XPASUEMaieWVNTRCtJ4S8H+9
    #       ssh.dev.azure.com ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC7Hr1oTWqNqOlzGJOfGJ4NakVyIzf1rXYd4d7wo6jBlkLvCA4odBlL0mDUyZ0/QUfTTqeu+tm22gOsv+VrVTMk6vwRU75gY/y9ut5Mb3bR5BV58dKXyq9A9UeB5Cakehn5Zgm6x1mKoVyf+FFn26iYqXJRgzIZZcZ5V6hrE0Qg39kZm4az48o0AUbf6Sp4SLdvnuMa2sVNwHBboS7EJkm57XQPVU3/QpyNLHbWDdzwtrlS+ez30S3AdYhLKEOxAG8weOnyrtLJAUen9mTkol8oII1edf7mWWbWVf0nBmly21+nZcmCTISQBtdcyPaEno7fFQMDD26/s0lfKob4Kw8H
    #       vs-ssh.visualstudio.com ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC7Hr1oTWqNqOlzGJOfGJ4NakVyIzf1rXYd4d7wo6jBlkLvCA4odBlL0mDUyZ0/QUfTTqeu+tm22gOsv+VrVTMk6vwRU75gY/y9ut5Mb3bR5BV58dKXyq9A9UeB5Cakehn5Zgm6x1mKoVyf+FFn26iYqXJRgzIZZcZ5V6hrE0Qg39kZm4az48o0AUbf6Sp4SLdvnuMa2sVNwHBboS7EJkm57XQPVU3/QpyNLHbWDdzwtrlS+ez30S3AdYhLKEOxAG8weOnyrtLJAUen9mTkol8oII1edf7mWWbWVf0nBmly21+nZcmCTISQBtdcyPaEno7fFQMDD26/s0lfKob4Kw8H

    # -- Repositories list to be used by applications
    ## Creates a secret for each key/value specified below to create repositories
    ## Note: the last example in the list would use a repository credential template, configured under "configs.repositoryCredentials".
    repositories:
      github-homelab-pi-k3s:
        name: github-homelab-pi-k3s
        url: https://github.com/Franjly/homelab-pi-k3s.git
        type: git
      github-argocd-homelab-pi-k3s:
        name: github-argocd-homelab-pi-k3s
        url: https://github.com/Franjly/argocd-homelab-pi-k3s.git
        type: git
      gitea-homelab-pi-k3s:
        name: gitea-homelab-pi-k3s
        url: https://gitea.local.tecno-fly.com/homelab/homelab-pi-k3s.git
        type: git
        insecure: "true"
      gitea-argocd-homelab-pi-k3s:
        name: gitea-argocd-homelab-pi-k3s
        url: https://gitea.local.tecno-fly.com/homelab/argocd-homelab-pi-k3s.git
        type: git
        insecure: "true"

    # -- Annotations to be added to `configs.repositories` Secret
    repositoriesAnnotations: {}

    secret:
      # -- add additional secrets to be added to argocd-secret
      ## Custom secrets. Useful for injecting SSO secrets into environment variables.
      ## Ref: https://argo-cd.readthedocs.io/en/stable/operator-manual/user-management/#sensitive-data-and-sso-client-secrets
      ## Note that all values must be non-empty.
      extra:
        {}
        # LDAP_PASSWORD: "mypassword"

      # -- Bcrypt hashed admin password
      ## Argo expects the password in the secret to be bcrypt hashed. You can create this hash with
      ## `htpasswd -nbBC 10 "" $ARGO_PWD | tr -d ':\n' | sed 's/$2y/$2a/'`
      argocdServerAdminPassword: ""
      # -- Admin password modification time. Eg. `"2006-01-02T15:04:05Z"`
      # @default -- `""` (defaults to current time)
      argocdServerAdminPasswordMtime: ""

    params:
      server.insecure: false

  # -- Array of extra K8s manifests to deploy
  extraObjects:
    - apiVersion: v1
      kind: ServiceAccount
      metadata:
        name: argocd-repo-server
        namespace: argocd
    - apiVersion: v1
      kind: Secret
      metadata:
        name: argocd-repo-server
        namespace: argocd
        annotations:
          kubernetes.io/service-account.name: argocd-repo-server
      type: kubernetes.io/service-account-token
    - apiVersion: rbac.authorization.k8s.io/v1
      kind: ClusterRoleBinding
      metadata:
        name: argocd-role-tokenreview-binding
      roleRef:
        apiGroup: rbac.authorization.k8s.io
        kind: ClusterRole
        name: system:auth-delegator
      subjects:
        - kind: ServiceAccount
          name: argocd-repo-server
          namespace: argocd
    - apiVersion: v1
      kind: Secret
      metadata:
        name: argocd-vault-plugin-credentials
        namespace: argocd
      type: Opaque
      data:
          VAULT_ADDR: aHR0cDovL3ZhdWx0LnZhdWx0LnN2Yy5jbHVzdGVyLmxvY2FsOjgyMDA=
          AVP_TYPE: dmF1bHQ=
          AVP_AUTH_TYPE: azhz
          AVP_K8S_ROLE: YXJnb2Nk

  controller:
    metrics:
      enabled: true
      applicationLabels:
        # -- Enables additional labels in argocd_app_labels metric
        enabled: false
        # -- Additional labels
        labels: []
      service:
        # -- Metrics service annotations
        annotations: {}
        # -- Metrics service labels
        labels: {}
        # -- Metrics service port
        servicePort: 8082
        # -- Metrics service port name
        portName: http-metrics
      serviceMonitor:
        # -- Enable a prometheus ServiceMonitor
        enabled: true
        # -- Prometheus ServiceMonitor interval
        interval: 30s
        # -- Prometheus [RelabelConfigs] to apply to samples before scraping
        relabelings: []
        # -- Prometheus [MetricRelabelConfigs] to apply to samples before ingestion
        metricRelabelings: []
        # -- Prometheus ServiceMonitor selector
        selector: {}
          # prometheus: kube-prometheus

        # -- Prometheus ServiceMonitor scheme
        scheme: ""
        # -- Prometheus ServiceMonitor tlsConfig
        tlsConfig: {}
        # -- Prometheus ServiceMonitor namespace
        namespace: "" # "monitoring"
        # -- Prometheus ServiceMonitor labels
        additionalLabels: {}
      rules:
        # -- Deploy a PrometheusRule for the application controller
        enabled: true
        # -- PrometheusRule.Spec for the application controller
        spec:
        - alert: ArgoAppMissing
          expr: |
            absent(argocd_app_info)
          for: 15m
          labels:
            severity: critical
          annotations:
            summary: "[Argo CD] No reported applications"
            description: >
              Argo CD has not reported any applications data for the past 15 minutes which
              means that it must be down or not functioning properly.  This needs to be
              resolved for this cloud to continue to maintain state.
        - alert: ArgoAppNotSynced
          expr: |
            argocd_app_info{sync_status!="Synced"} == 1
          for: 12h
          labels:
            severity: warning
          annotations:
            summary: "**[{{$labels.name}}]** Application not synchronized"
            description: >
              The application **[{{$labels.name}}]** has not been synchronized for over
              12 hours which means that the state of this cloud has drifted away from the
              state inside Git.
      #   selector:
      #     prometheus: kube-prometheus
      #   namespace: monitoring
      #   additionalLabels: {}

  ## Dex
  dex:
    metrics:
      # -- Deploy metrics service
      enabled: false
      service:
        # -- Metrics service annotations
        annotations: {}
        # -- Metrics service labels
        labels: {}
        # -- Metrics service port name
        portName: http-metrics
      serviceMonitor:
        # -- Enable a prometheus ServiceMonitor
        enabled: false
        # -- Prometheus ServiceMonitor interval
        interval: 30s
        # -- Prometheus [RelabelConfigs] to apply to samples before scraping
        relabelings: []
        # -- Prometheus [MetricRelabelConfigs] to apply to samples before ingestion
        metricRelabelings: []
        # -- Prometheus ServiceMonitor selector
        selector: {}
          # prometheus: kube-prometheus

        # -- Prometheus ServiceMonitor scheme
        scheme: ""
        # -- Prometheus ServiceMonitor tlsConfig
        tlsConfig: {}
        # -- Prometheus ServiceMonitor namespace
        namespace: "" # "monitoring"
        # -- Prometheus ServiceMonitor labels
        additionalLabels: {}

  redis:
    metrics:
      # -- Deploy metrics service and redis-exporter sidecar
      enabled: false
      image:
        # -- redis-exporter image repository
        repository: public.ecr.aws/bitnami/redis-exporter
        # -- redis-exporter image tag
        tag: 1.26.0-debian-10-r2
        # -- redis-exporter image PullPolicy
        imagePullPolicy: IfNotPresent
      # -- Port to use for redis-exporter sidecar
      containerPort: 9121
      # -- Resource limits and requests for redis-exporter sidecar
      resources: {}
        # limits:
        #   cpu: 50m
        #   memory: 64Mi
        # requests:
        #   cpu: 10m
        #   memory: 32Mi
      service:
        # -- Metrics service type
        type: ClusterIP
        # -- Metrics service clusterIP. `None` makes a "headless service" (no virtual IP)
        clusterIP: None
        # -- Metrics service annotations
        annotations: {}
        # -- Metrics service labels
        labels: {}
        # -- Metrics service port
        servicePort: 9121
        # -- Metrics service port name
        portName: http-metrics
      serviceMonitor:
        # -- Enable a prometheus ServiceMonitor
        enabled: false
        # -- Interval at which metrics should be scraped
        interval: 30s
        # -- Prometheus [RelabelConfigs] to apply to samples before scraping
        relabelings: []
        # -- Prometheus [MetricRelabelConfigs] to apply to samples before ingestion
        metricRelabelings: []
        # -- Prometheus ServiceMonitor selector
        selector: {}
          # prometheus: kube-prometheus

        # -- Prometheus ServiceMonitor scheme
        scheme: ""
        # -- Prometheus ServiceMonitor tlsConfig
        tlsConfig: {}
        # -- Prometheus ServiceMonitor namespace
        namespace: "" # "monitoring"
        # -- Prometheus ServiceMonitor labels
        additionalLabels: {}

  ## Server
  server:
    # ## Certificate configuration
    # certificate:
    #   # -- Deploy a Certificate resource (requires cert-manager)
    #   enabled: false
    #   # -- Certificate primary domain (commonName)
    #   domain: argocd.example.com
    #   # -- The requested 'duration' (i.e. lifetime) of the Certificate. Value must be in units accepted by Go time.ParseDuration
    #   duration: ""
    #   # -- How long before the currently issued certificate's expiry cert-manager should renew the certificate. Value must be in units accepted by Go time.ParseDuration
    #   renewBefore: ""
    #   # Private key of the certificate
    #   privateKey:
    #     # -- Rotation policy of private key when certificate is re-issued. Either: `Never` or `Always`
    #     rotationPolicy: Never
    #     # -- The private key cryptography standards (PKCS) encoding for private key. Either: `PCKS1` or `PKCS8`
    #     encoding: PKCS1
    #     # -- Algorithm used to generate certificate private key. One of: `RSA`, `Ed25519` or `ECDSA`
    #     algorithm: RSA
    #     # -- Key bit size of the private key. If algorithm is set to `Ed25519`, size is ignored.
    #     size: 2048
    #   issuer:
    #     # -- Certificate issuer group. Set if using an external issuer. Eg. `cert-manager.io`
    #     group: ""
    #     # -- Certificate issuer kind. Either `Issuer` or `ClusterIssuer`
    #     kind: ""
    #     # -- Certificate isser name. Eg. `letsencrypt`
    #     name: ""
    #   # -- Certificate manager additional hosts
    #   additionalHosts: []
    #   # -- The name of the Secret that will be automatically created and managed by this Certificate resource
    #   secretName: argocd-server-tls

    ## Server metrics service configuration
    metrics:
      # -- Deploy metrics service
      enabled: true
      service:
        # -- Metrics service annotations
        annotations: {}
        # -- Metrics service labels
        labels: {}
        # -- Metrics service port
        servicePort: 8083
        # -- Metrics service port name
        portName: http-metrics
      serviceMonitor:
        # -- Enable a prometheus ServiceMonitor
        enabled: true
        # -- Prometheus ServiceMonitor interval
        interval: 30s
        # -- Prometheus [RelabelConfigs] to apply to samples before scraping
        relabelings: []
        # -- Prometheus [MetricRelabelConfigs] to apply to samples before ingestion
        metricRelabelings: []
        # -- Prometheus ServiceMonitor selector
        selector: {}
          # prometheus: kube-prometheus

        # -- Prometheus ServiceMonitor scheme
        scheme: ""
        # -- Prometheus ServiceMonitor tlsConfig
        tlsConfig: {}
        # -- Prometheus ServiceMonitor namespace
        namespace: ""  # monitoring
        # -- Prometheus ServiceMonitor labels
        additionalLabels: {}

    ingress:
      enabled: true
      
      annotations:
        nginx.ingress.kubernetes.io/force-ssl-redirect: "true"
        nginx.ingress.kubernetes.io/ssl-passthrough: "true"
        cert-manager.io/cluster-issuer: letsencrypt-staging
      
      ingressClassName: "nginx"

      hosts:
        - argocd.local.tecno-fly.com

      paths:
        - /
      pathType: Prefix
      tls:
        - secretName: argocd-tls-certificate
          hosts:
            - argocd.local.tecno-fly.com

    # dedicated ingress for gRPC as documented at
    # Ref: https://argo-cd.readthedocs.io/en/stable/operator-manual/ingress/
    ingressGrpc:
      # -- Enable an ingress resource for the Argo CD server for dedicated [gRPC-ingress]
      enabled: false
      # -- Setup up gRPC ingress to work with an AWS ALB
      isAWSALB: false
      # -- Additional ingress annotations for dedicated [gRPC-ingress]
      annotations: {}
      # -- Additional ingress labels for dedicated [gRPC-ingress]
      labels: {}
      # -- Defines which ingress controller will implement the resource [gRPC-ingress]
      ingressClassName: ""

      awsALB:
        # -- Service type for the AWS ALB gRPC service
        ## Service Type if isAWSALB is set to true
        ## Can be of type NodePort or ClusterIP depending on which mode you are
        ## are running. Instance mode needs type NodePort, IP mode needs type
        ## ClusterIP
        ## Ref: https://kubernetes-sigs.github.io/aws-load-balancer-controller/v2.2/how-it-works/#ingress-traffic
        serviceType: NodePort
        # -- Backend protocol version for the AWS ALB gRPC service
        ## This tells AWS to send traffic from the ALB using HTTP2. Can use gRPC as well if you want to leverage gRPC specific features
        backendProtocolVersion: HTTP2

      # -- List of ingress hosts for dedicated [gRPC-ingress]
      ## Argo Ingress.
      ## Hostnames must be provided if Ingress is enabled.
      ## Secrets must be manually created in the namespace
      ##
      hosts:
        []
        # - argocd.example.com

      # -- List of ingress paths for dedicated [gRPC-ingress]
      paths:
        - /
      # -- Ingress path type for dedicated [gRPC-ingress]. One of `Exact`, `Prefix` or `ImplementationSpecific`
      pathType: Prefix
      # -- Additional ingress paths for dedicated [gRPC-ingress]
      extraPaths:
        []
        # - path: /*
        #   backend:
        #     serviceName: ssl-redirect
        #     servicePort: use-annotation
        ## for Kubernetes >=1.19 (when "networking.k8s.io/v1" is used)
        # - path: /*
        #   pathType: Prefix
        #   backend:
        #     service:
        #       name: ssl-redirect
        #       port:
        #         name: use-annotation

      # -- Ingress TLS configuration for dedicated [gRPC-ingress]
      tls:
        []
        # - secretName: argocd-tls-certificate
        #   hosts:
        #     - argocd.example.com

      # -- Uses `server.service.servicePortHttps` instead `server.service.servicePortHttp`
      https: false


    # -- Manage Argo CD configmap (Declarative Setup)
    ## Ref: https://github.com/argoproj/argo-cd/blob/master/docs/operator-manual/argocd-cm.yaml
    configEnabled: true
    # -- [General Argo CD configuration]
    # @default -- See [values.yaml]
    config:
      exec.enabled: "true"
      admin.enabled: "false"
      accounts.fly: apiKey, login, exec
      accounts.argocd: apiKey, login, exec
      configManagementPlugins: |-
        - name: argocd-vault-plugin
          generate:
            command: ["argocd-vault-plugin"]
            args: ["generate", "./"]
        - name: kustomized-helm
          init:
            command: ["/bin/sh", "-c"]
            args: ["helm dependency build"]
          generate:
            command: [sh, -c]
            args: ["helm template $ARGOCD_APP_NAME --include-crds --namespace $ARGOCD_APP_NAMESPACE . > resources/all.yaml && kustomize build"]
        - name: vault-kustomized-helm
          init:
            command: ["/bin/sh", "-c"]
            args: ["helm dependency build"]
          generate:
            command: [sh, -c]
            args: ["helm template $ARGOCD_APP_NAME --include-crds --namespace $ARGOCD_APP_NAMESPACE . > resources/all.yaml && kustomize build | argocd-vault-plugin generate -"]
      resource.customizations.health.argoproj.io_Application: |
        hs = {}
        hs.status = "Progressing"
        hs.message = ""
        if obj.status ~= nil then
          if obj.status.health ~= nil then
            hs.status = obj.status.health.status
            if obj.status.health.message ~= nil then
              hs.message = obj.status.health.message
            end
          end
        end
        return hs

      # dex.config: |
      #   connectors:
      #     # GitHub example
      #     - type: github
      #       id: github
      #       name: GitHub
      #       config:
      #         clientID: aabbccddeeff00112233
      #         clientSecret: $dex.github.clientSecret # Alternatively $<some_K8S_secret>:dex.github.clientSecret
      #         orgs:
      #         - name: your-github-org

    rbacConfig:
        policy.default: role:readonly
        policy.csv: |
          p, role:argocd, applications, *, */*, allow
          p, role:argocd, projects, *, *, allow
          p, role:argocd, repositories, *, *, allow
          g, fly, role:admin
          g, argocd, role:argocd

  repoServer:

    # -- Additional command line arguments to pass to repo server
    extraArgs: []

    # -- Environment variables to pass to repo server
    env: []

    envFrom:
    # - configMapRef:
    #     name: config-map-name
    - secretRef:
        name: argocd-vault-plugin-credentials


    # -- Additional volumeMounts to the repo server main container
    volumeMounts:
      - name: custom-tools
        mountPath: /usr/local/bin/argocd-vault-plugin
        subPath: argocd-vault-plugin

    # -- Additional volumes to the repo server pod
    volumes:
      - name: custom-tools
        emptyDir: {}

    ## Repo server metrics service configuration
    metrics:
      # -- Deploy metrics service
      enabled: true
      service:
        # -- Metrics service annotations
        annotations: {}
        # -- Metrics service labels
        labels: {}
        # -- Metrics service port
        servicePort: 8084
        # -- Metrics service port name
        portName: http-metrics
      serviceMonitor:
        # -- Enable a prometheus ServiceMonitor
        enabled: true
        # -- Prometheus ServiceMonitor interval
        interval: 30s
        # -- Prometheus [RelabelConfigs] to apply to samples before scraping
        relabelings: []
        # -- Prometheus [MetricRelabelConfigs] to apply to samples before ingestion
        metricRelabelings: []
        # -- Prometheus ServiceMonitor selector
        selector: {}
          # prometheus: kube-prometheus

        # -- Prometheus ServiceMonitor scheme
        scheme: ""
        # -- Prometheus ServiceMonitor tlsConfig
        tlsConfig: {}
        # -- Prometheus ServiceMonitor namespace
        namespace: "" # "monitoring"
        # -- Prometheus ServiceMonitor labels
        additionalLabels: {}

    ## Repo server service account
    ## If create is set to true, make sure to uncomment the name and update the rbac section below
    serviceAccount:
      create: false
      name: "argocd-repo-server"
      automountServiceAccountToken: true

    # -- Init containers to add to the repo server pods
    initContainers:
      - name: download-tools
        image: alpine:3.8
        command: [sh, -c]
        args:
          - wget -O argocd-vault-plugin
            https://github.com/argoproj-labs/argocd-vault-plugin/releases/download/v1.13.0/argocd-vault-plugin_1.13.0_linux_arm64

            chmod +x argocd-vault-plugin && mv argocd-vault-plugin /custom-tools/
        volumeMounts:
          - mountPath: /custom-tools
            name: custom-tools

  applicationSet:
    ## Metrics service configuration
    metrics:
      # -- Deploy metrics service
      enabled: true
      service:
        # -- Metrics service annotations
        annotations: {}
        # -- Metrics service labels
        labels: {}
        # -- Metrics service port
        servicePort: 8085
        # -- Metrics service port name
        portName: http-metrics
      serviceMonitor:
        # -- Enable a prometheus ServiceMonitor
        enabled: true
        # -- Prometheus ServiceMonitor interval
        interval: 30s
        # -- Prometheus [RelabelConfigs] to apply to samples before scraping
        relabelings: []
        # -- Prometheus [MetricRelabelConfigs] to apply to samples before ingestion
        metricRelabelings: []
        # -- Prometheus ServiceMonitor selector
        selector: {}
          # prometheus: kube-prometheus

        # -- Prometheus ServiceMonitor scheme
        scheme: ""
        # -- Prometheus ServiceMonitor tlsConfig
        tlsConfig: {}
        # -- Prometheus ServiceMonitor namespace
        namespace: ""  # monitoring
        # -- Prometheus ServiceMonitor labels
        additionalLabels: {}

  notifications:
    # -- Enable Notifications controller
    enabled: true

    # -- Notifications controller name string
    name: notifications-controller

    # -- Assign custom [affinity] rules
    affinity: {}

    # -- Argo CD dashboard url; used in place of {{.context.argocdUrl}} in templates
    argocdUrl:

    image:
      # -- Repository to use for the notifications controller
      # @default -- `""` (defaults to global.image.repository)
      repository: ""
      # -- Tag to use for the notifications controller
      # @default -- `""` (defaults to global.image.tag)
      tag: ""
      # -- Image pull policy for the notifications controller
      # @default -- `""` (defaults to global.image.imagePullPolicy)
      imagePullPolicy: ""

    # -- Secrets with credentials to pull images from a private registry
    imagePullSecrets: []

    # -- [Node selector]
    nodeSelector: {}

    # -- The deployment strategy to use to replace existing pods with new ones
    updateStrategy:
      type: Recreate

    # -- Define user-defined context
    ## For more information: https://argocd-notifications.readthedocs.io/en/stable/templates/#defining-user-defined-context
    context: {}
      # region: east
      # environmentName: staging

    secret:
      # -- Whether helm chart creates controller secret
      create: true

      # -- key:value pairs of annotations to be added to the secret
      annotations: {}

      # -- Generic key:value pairs to be inserted into the secret
      ## Can be used for templates, notification services etc. Some examples given below.
      ## For more information: https://argocd-notifications.readthedocs.io/en/stable/services/overview/
      items: {}
        # slack-token:
        #   # For more information: https://argocd-notifications.readthedocs.io/en/stable/services/slack/

        # grafana-apiKey:
        #   # For more information: https://argocd-notifications.readthedocs.io/en/stable/services/grafana/

        # webhooks-github-token:

        # email-username:
        # email-password:
          # For more information: https://argocd-notifications.readthedocs.io/en/stable/services/email/

    # -- Application controller log format. Either `text` or `json`
    # @default -- `""` (defaults to global.logging.format)
    logFormat: ""
    # -- Application controller log level. One of: `debug`, `info`, `warn`, `error`
    # @default -- `""` (defaults to global.logging.level)
    logLevel: ""

    # -- Extra arguments to provide to the controller
    extraArgs: []

    # -- Additional container environment variables
    extraEnv: []

    # -- List of extra mounts to add (normally used with extraVolumes)
    extraVolumeMounts: []
      # - mountPath: /tmp/foobar
      #   name: foobar

    # -- List of extra volumes to add
    extraVolumes: []
      # - name: foobar
      #   emptyDir: {}

    metrics:
      # -- Enables prometheus metrics server
      enabled: true
      # -- Metrics port
      port: 9001
      service:
        # -- Metrics service annotations
        annotations: {}
        # -- Metrics service labels
        labels: {}
        # -- Metrics service port name
        portName: http-metrics
      serviceMonitor:
        # -- Enable a prometheus ServiceMonitor
        enabled: true
        # -- Prometheus ServiceMonitor selector
        selector: {}
          # prometheus: kube-prometheus
        # -- Prometheus ServiceMonitor labels
        additionalLabels: {}
        # namespace: monitoring
        # interval: 30s
        # scrapeTimeout: 10s
        # -- Prometheus ServiceMonitor scheme
        scheme: ""
        # -- Prometheus ServiceMonitor tlsConfig
        tlsConfig: {}

    # -- Configures notification services such as slack, email or custom webhook
    # @default -- See [values.yaml]
    ## For more information: https://argocd-notifications.readthedocs.io/en/stable/services/overview/
    notifiers:
      service.webhook.discord: |
        url: <path:pi-k3s/data/platform/argocd#DISCORD_WEBHOOK>

    # -- Annotations to be applied to the controller Pods
    podAnnotations: {}

    # -- Labels to be applied to the controller Pods
    podLabels: {}

    # -- Pod Security Context
    securityContext:
      runAsNonRoot: true

    # -- Container Security Context
    containerSecurityContext: {}

    # -- Priority class for the controller pods
    priorityClassName: ""

    # -- Resource limits and requests for the controller
    resources: {}
      # limits:
      #   cpu: 100m
      #   memory: 128Mi
      # requests:
      #   cpu: 100m
      #   memory: 128Mi

    serviceAccount:
      # -- Specifies whether a service account should be created
      create: true

      # -- The name of the service account to use.
      ## If not set and create is true, a name is generated using the fullname template
      name: argocd-notifications-controller

      # -- Annotations applied to created service account
      annotations: {}

    cm:
      # -- Whether helm chart creates controller config map
      create: true

    # -- Contains centrally managed global application subscriptions
    ## For more information: https://argocd-notifications.readthedocs.io/en/stable/subscriptions/
    subscriptions:
      # subscription for on-sync-status-unknown trigger notifications
      - recipients:
        - discord
        triggers:
        - on-deployed
        - on-health-degraded
        - on-sync-failed
        - on-sync-running
        - on-sync-status-unknown
        - on-sync-succeeded
      # # subscription for on-sync-status-unknown trigger notifications
      # - recipients:
      #   - slack:test2
      #   - email:test@gmail.com
      #   triggers:
      #   - on-sync-status-unknown
      # # subscription restricted to applications with matching labels only
      # - recipients:
      #   - slack:test3
      #   selector: test=true
      #   triggers:
      #   - on-sync-status-unknown

    # -- The notification template is used to generate the notification content
    ## For more information: https://argocd-notifications.readthedocs.io/en/stable/templates/
    templates:
      template.app-deployed: |
        webhook:
          discord:
            method: POST
            body: |
              {
                "content": null,
                "embeds": [
                  {
                    "title": "[{{ .app.metadata.name}}] - New version of an application {{.app.metadata.name}} is up and running.",
                    "description": "Application {{.app.metadata.name}} is now running new version of deployments manifests.",
                    "url": "{{.context.argocdUrl}}/applications/{{.app.metadata.name}}",
                    "color": 1621586,
                    "fields": [
                      {
                        "name": "Sync Status",
                        "value": "{{.app.status.sync.status}}"
                      },
                      {
                        "name": "Repository",
                        "value": "{{.app.spec.source.repoURL}}"
                      },
                      {
                        "name": "Revision",
                        "value": "{{.app.status.sync.revision}}"
                      }
                      {{range $index, $c := .app.status.conditions}}
                      {{if not $index}},{{end}}
                      {{if $index}},{{end}}
                      {
                        "name": "{{$c.type}}",
                        "value": "{{$c.message}}",
                      }
                      {{end}}
                    ]
                  }
                ],
                "attachments": []
              }
      #   email:
      #     subject: New version of an application {{.app.metadata.name}} is up and running.
      #   message: |
      #     {{if eq .serviceType "slack"}}:white_check_mark:{{end}} Application {{.app.metadata.name}} is now running new version of deployments manifests.
      #   slack:
      #     attachments: |
      #       [{
      #         "title": "{{ .app.metadata.name}}",
      #         "title_link":"{{.context.argocdUrl}}/applications/{{.app.metadata.name}}",
      #         "color": "#18be52",
      #         "fields": [
      #         {
      #           "title": "Sync Status",
      #           "value": "{{.app.status.sync.status}}",
      #           "short": true
      #         },
      #         {
      #           "title": "Repository",
      #           "value": "{{.app.spec.source.repoURL}}",
      #           "short": true
      #         },
      #         {
      #           "title": "Revision",
      #           "value": "{{.app.status.sync.revision}}",
      #           "short": true
      #         }
      #         {{range $index, $c := .app.status.conditions}}
      #         {{if not $index}},{{end}}
      #         {{if $index}},{{end}}
      #         {
      #           "title": "{{$c.type}}",
      #           "value": "{{$c.message}}",
      #           "short": true
      #         }
      #         {{end}}
      #         ]
      #       }]
      # template.app-health-degraded: |
      #   email:
      #     subject: Application {{.app.metadata.name}} has degraded.
      #   message: |
      #     {{if eq .serviceType "slack"}}:exclamation:{{end}} Application {{.app.metadata.name}} has degraded.
      #     Application details: {{.context.argocdUrl}}/applications/{{.app.metadata.name}}.
      #   slack:
      #     attachments: |-
      #       [{
      #         "title": "{{ .app.metadata.name}}",
      #         "title_link": "{{.context.argocdUrl}}/applications/{{.app.metadata.name}}",
      #         "color": "#f4c030",
      #         "fields": [
      #         {
      #           "title": "Sync Status",
      #           "value": "{{.app.status.sync.status}}",
      #           "short": true
      #         },
      #         {
      #           "title": "Repository",
      #           "value": "{{.app.spec.source.repoURL}}",
      #           "short": true
      #         }
      #         {{range $index, $c := .app.status.conditions}}
      #         {{if not $index}},{{end}}
      #         {{if $index}},{{end}}
      #         {
      #           "title": "{{$c.type}}",
      #           "value": "{{$c.message}}",
      #           "short": true
      #         }
      #         {{end}}
      #         ]
      #       }]
      # template.app-sync-failed: |
      #   email:
      #     subject: Failed to sync application {{.app.metadata.name}}.
      #   message: |
      #     {{if eq .serviceType "slack"}}:exclamation:{{end}}  The sync operation of application {{.app.metadata.name}} has failed at {{.app.status.operationState.finishedAt}} with the following error: {{.app.status.operationState.message}}
      #     Sync operation details are available at: {{.context.argocdUrl}}/applications/{{.app.metadata.name}}?operation=true .
      #   slack:
      #     attachments: |-
      #       [{
      #         "title": "{{ .app.metadata.name}}",
      #         "title_link":"{{.context.argocdUrl}}/applications/{{.app.metadata.name}}",
      #         "color": "#E96D76",
      #         "fields": [
      #         {
      #           "title": "Sync Status",
      #           "value": "{{.app.status.sync.status}}",
      #           "short": true
      #         },
      #         {
      #           "title": "Repository",
      #           "value": "{{.app.spec.source.repoURL}}",
      #           "short": true
      #         }
      #         {{range $index, $c := .app.status.conditions}}
      #         {{if not $index}},{{end}}
      #         {{if $index}},{{end}}
      #         {
      #           "title": "{{$c.type}}",
      #           "value": "{{$c.message}}",
      #           "short": true
      #         }
      #         {{end}}
      #         ]
      #       }]
      # template.app-sync-running: |
      #   email:
      #     subject: Start syncing application {{.app.metadata.name}}.
      #   message: |
      #     The sync operation of application {{.app.metadata.name}} has started at {{.app.status.operationState.startedAt}}.
      #     Sync operation details are available at: {{.context.argocdUrl}}/applications/{{.app.metadata.name}}?operation=true .
      #   slack:
      #     attachments: |-
      #       [{
      #         "title": "{{ .app.metadata.name}}",
      #         "title_link":"{{.context.argocdUrl}}/applications/{{.app.metadata.name}}",
      #         "color": "#0DADEA",
      #         "fields": [
      #         {
      #           "title": "Sync Status",
      #           "value": "{{.app.status.sync.status}}",
      #           "short": true
      #         },
      #         {
      #           "title": "Repository",
      #           "value": "{{.app.spec.source.repoURL}}",
      #           "short": true
      #         }
      #         {{range $index, $c := .app.status.conditions}}
      #         {{if not $index}},{{end}}
      #         {{if $index}},{{end}}
      #         {
      #           "title": "{{$c.type}}",
      #           "value": "{{$c.message}}",
      #           "short": true
      #         }
      #         {{end}}
      #         ]
      #       }]
      # template.app-sync-status-unknown: |
      #   email:
      #     subject: Application {{.app.metadata.name}} sync status is 'Unknown'
      #   message: |
      #     {{if eq .serviceType "slack"}}:exclamation:{{end}} Application {{.app.metadata.name}} sync is 'Unknown'.
      #     Application details: {{.context.argocdUrl}}/applications/{{.app.metadata.name}}.
      #     {{if ne .serviceType "slack"}}
      #     {{range $c := .app.status.conditions}}
      #         * {{$c.message}}
      #     {{end}}
      #     {{end}}
      #   slack:
      #     attachments: |-
      #       [{
      #         "title": "{{ .app.metadata.name}}",
      #         "title_link":"{{.context.argocdUrl}}/applications/{{.app.metadata.name}}",
      #         "color": "#E96D76",
      #         "fields": [
      #         {
      #           "title": "Sync Status",
      #           "value": "{{.app.status.sync.status}}",
      #           "short": true
      #         },
      #         {
      #           "title": "Repository",
      #           "value": "{{.app.spec.source.repoURL}}",
      #           "short": true
      #         }
      #         {{range $index, $c := .app.status.conditions}}
      #         {{if not $index}},{{end}}
      #         {{if $index}},{{end}}
      #         {
      #           "title": "{{$c.type}}",
      #           "value": "{{$c.message}}",
      #           "short": true
      #         }
      #         {{end}}
      #         ]
      #       }]
      template.app-sync-succeeded: |
        webhook:
          discord:
            method: POST
            body: |
              {
                "content": null,
                "embeds": [
                  {
                    "title": "[{{ .app.metadata.name}}] - Application {{.app.metadata.name}} has been successfully synced.",
                    "description": "Application {{.app.metadata.name}} has been successfully synced at {{.app.status.operationState.finishedAt}}.\nSync operation details are available at: {{.context.argocdUrl}}/applications/{{.app.metadata.name}}?operation=true .",
                    "url": "{{.context.argocdUrl}}/applications/{{.app.metadata.name}}",
                    "color": 1621586,
                    "fields": [
                      {
                        "name": "Sync Status",
                        "value": "{{.app.status.sync.status}}"
                      },
                      {
                        "name": "Repository",
                        "value": "{{.app.spec.source.repoURL}}"
                      }
                      {{range $index, $c := .app.status.conditions}}
                      {{if not $index}},{{end}}
                      {{if $index}},{{end}}
                      {
                        "title": "{{$c.type}}",
                        "value": "{{$c.message}}",
                        "short": true
                      }
                      {{end}}
                    ]
                  }
                ],
                "attachments": []
              }  
      #   email:
      #     subject: Application {{.app.metadata.name}} has been successfully synced.
      #   message: |
      #     {{if eq .serviceType "slack"}}:white_check_mark:{{end}} Application {{.app.metadata.name}} has been successfully synced at {{.app.status.operationState.finishedAt}}.
      #     Sync operation details are available at: {{.context.argocdUrl}}/applications/{{.app.metadata.name}}?operation=true .
      #   slack:
      #     attachments: |-
      #       [{
      #         "title": "{{ .app.metadata.name}}",
      #         "title_link":"{{.context.argocdUrl}}/applications/{{.app.metadata.name}}",
      #         "color": "#18be52",
      #         "fields": [
      #         {
      #           "title": "Sync Status",
      #           "value": "{{.app.status.sync.status}}",
      #           "short": true
      #         },
      #         {
      #           "title": "Repository",
      #           "value": "{{.app.spec.source.repoURL}}",
      #           "short": true
      #         }
      #         {{range $index, $c := .app.status.conditions}}
      #         {{if not $index}},{{end}}
      #         {{if $index}},{{end}}
      #         {
      #           "title": "{{$c.type}}",
      #           "value": "{{$c.message}}",
      #           "short": true
      #         }
      #         {{end}}
      #         ]
      #       }]

    # -- [Tolerations] for use with node taints
    tolerations: []

    # -- The trigger defines the condition when the notification should be sent
    ## For more information: https://argocd-notifications.readthedocs.io/en/stable/triggers/
    triggers:
      trigger.on-deployed: |
        - description: Application is synced and healthy. Triggered once per commit.
          oncePer: app.status.sync.revision
          send:
          - app-deployed
          when: app.status.operationState.phase in ['Succeeded'] and app.status.health.status == 'Healthy'
      trigger.on-health-degraded: |
        - description: Application has degraded
          send:
          - app-health-degraded
          when: app.status.health.status == 'Degraded'
      trigger.on-sync-failed: |
        - description: Application syncing has failed
          send:
          - app-sync-failed
          when: app.status.operationState.phase in ['Error', 'Failed']
      trigger.on-sync-running: |
        - description: Application is being synced
          send:
          - app-sync-running
          when: app.status.operationState.phase in ['Running']
      trigger.on-sync-status-unknown: |
        - description: Application status is 'Unknown'
          send:
          - app-sync-status-unknown
          when: app.status.sync.status == 'Unknown'
      trigger.on-sync-succeeded: |
        - description: Application syncing has succeeded
          send:
          - app-sync-succeeded
          when: app.status.operationState.phase in ['Succeeded']
      
      # For more information: https://argocd-notifications.readthedocs.io/en/stable/triggers/#default-triggers
      # defaultTriggers: |
      #   - on-sync-status-unknown

    ## The optional bot component simplifies managing subscriptions
    ## For more information: https://argocd-notifications.readthedocs.io/en/stable/bots/overview/
    bots:
      slack:
        # -- Enable slack bot
        ## You have to set secret.notifiers.slack.signingSecret
        enabled: false

        # -- The deployment strategy to use to replace existing pods with new ones
        updateStrategy:
          type: Recreate

        image:
          # -- Repository to use for the Slack bot
          # @default -- `""` (defaults to global.image.repository)
          repository: ""
          # -- Tag to use for the Slack bot
          # @default -- `""` (defaults to global.image.tag)
          tag: ""
          # -- Image pull policy for the Slack bot
          # @default -- `""` (defaults to global.image.imagePullPolicy)
          imagePullPolicy: ""

        # -- Secrets with credentials to pull images from a private registry
        imagePullSecrets: []

        service:
          # -- Service annotations for Slack bot
          annotations: {}
          # -- Service port for Slack bot
          port: 80
          # -- Service type for Slack bot
          type: LoadBalancer

        serviceAccount:
          # -- Specifies whether a service account should be created
          create: true

          # -- The name of the service account to use.
          ## If not set and create is true, a name is generated using the fullname template
          name: argocd-notifications-bot

          # -- Annotations applied to created service account
          annotations: {}

        # -- Pod Security Context
        securityContext:
          runAsNonRoot: true

        # -- Container Security Context
        containerSecurityContext: {}

        # -- Resource limits and requests for the Slack bot
        resources: {}
        # limits:
        #   cpu: 100m
        #   memory: 128Mi
        # requests:
        #   cpu: 100m
        #   memory: 128Mi

        # -- Assign custom [affinity] rules
        affinity: {}

        # -- [Tolerations] for use with node taints
        tolerations: []

        # -- [Node selector]
        nodeSelector: {}